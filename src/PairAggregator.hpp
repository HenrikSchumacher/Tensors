#pragma once

namespace Tensors
{
    template<typename T_0, typename T_1, typename LInt, int BUFFER_CAP = 128>
    class alignas(ObjectAlignment) PairAggregator final
    {
        static_assert(IntQ<LInt>,"");

        using Container_0_T = Tensor1<T_0,LInt>;
        using Container_1_T = Tensor1<T_1,LInt>;

        mutable LInt current_size = LInt(0);
        mutable LInt capacity     = LInt(1);

        mutable LInt current_buffer_size = LInt(0);
        mutable std::array<T_0,BUFFER_CAP> buffer_0;
        mutable std::array<T_1,BUFFER_CAP> buffer_1;
        
        mutable Container_0_T container_0 {static_cast<LInt>(BUFFER_CAP)};
        mutable Container_1_T container_1 {static_cast<LInt>(BUFFER_CAP)};

    public:

        explicit PairAggregator( const LInt n )
        :   current_size ( LInt(0)             )
        ,   capacity     ( Max(static_cast<LInt>(BUFFER_CAP),n) )
        ,   container_0  ( Max(static_cast<LInt>(BUFFER_CAP),n) )
        ,   container_1  ( Max(static_cast<LInt>(BUFFER_CAP),n) )
        {}

        // Default constructor
        PairAggregator() = default;
        
        // Since we declare no user-defined destructor, suitable copy constructor, copy assignment, move constructor, and copy assignment will be generated by compiler.
        
//        // Destructor
//        ~PairAggregator() = default;
//        // Copy constructor
//        PairAggregator( const PairAggregator & other )
//        :   current_size        ( other.current_size        )
//        ,   capacity            ( other.capacity            )
//        ,   current_buffer_size ( other.current_buffer_size )
//        ,   buffer_0            ( other.buffer_0            )
//        ,   buffer_1            ( other.buffer_1            )
//        ,   container_0         ( other.container_0         )
//        ,   container_1         ( other.container_1         )
//        {}
//
//        friend void swap ( PairAggregator & A, PairAggregator & B ) noexcept
//        {
//            using std::swap;
//            
//            swap( A.current_size,        B.current_size         );
//            swap( A.capacity,            B.capacity             );
//            swap( A.current_buffer_size, B.current_buffer_size  );
//            swap( A.buffer_0,            B.buffer_0             );
//            swap( A.buffer_1,            B.buffer_1             );
//            swap( A.container_0,         B.container_0          );
//            swap( A.container_1,         B.container_1          );
//        }
//        
//        // Copy assignment operator
//        PairAggregator & operator=( PairAggregator other ) noexcept
//        {   //                                 ^
//            //                                 |
//            // Use the copy constructor -------+
//            swap( *this, other );
//            return *this;
//        }
//
//        // Move constructor
//        PairAggregator( PairAggregator && other ) noexcept
//        :   PairAggregator()
//        {
//            swap(*this, other);
//        }

        LInt Size() const
        {
            return current_size + current_buffer_size;
        }

        void Push( const T_0 a, const T_1 b )
        {
            if( current_buffer_size >= BUFFER_CAP )
            {
                FlushBuffer();
            }

            buffer_0[current_buffer_size] = a;
            buffer_1[current_buffer_size] = b;
            ++current_buffer_size;
        }

        void Clear()
        {
            current_size        = 0;
            current_buffer_size = 0;
        }
        
        Container_0_T & Get_0()
        {
            Finalize();
            return container_0;
        }
        
        const Container_0_T & Get_0() const
        {
            Finalize();
            return container_0;
        }

        Container_1_T & Get_1()
        {
            Finalize();
            return container_1;
        }
        
        const Container_1_T & Get_1() const
        {
            Finalize();
            return container_1;
        }

    public:

        LInt Capacity() const
        {
            return capacity;
        }
        
        void RequireCapacity( const LInt new_capacity ) const
        {
            if( new_capacity > capacity)
            {
                SetCapacity( new_capacity );
            }
        }
        
        void SetCapacity( const LInt new_capacity ) const
        {
            Container_0_T new_container_0 (new_capacity);
            Container_1_T new_container_1 (new_capacity);
            
            const LInt s = Min( capacity, new_capacity );
            
            copy_buffer( container_0.data(), new_container_0.data(), s );
            copy_buffer( container_1.data(), new_container_1.data(), s );
            
            using std::swap;
            swap( container_0, new_container_0 );
            swap( container_1, new_container_1 );
            
            capacity = new_capacity;
        }
        
        void Finalize() const
        {
            if( current_buffer_size > LInt(0) )
            {
                RequireCapacity( current_size + current_buffer_size );
                
                copy_buffer( buffer_0.data(), container_0.data(current_size), current_buffer_size );
                copy_buffer( buffer_1.data(), container_1.data(current_size), current_buffer_size );
                
                current_size += current_buffer_size;
                current_buffer_size = 0;
            }
        }
        
    protected:
        
        void FlushBuffer() const
        {
            if( capacity < current_size + BUFFER_CAP )
            {
                Expand();
            }
            
            copy_buffer<BUFFER_CAP>( buffer_0.data(), &container_0.data()[current_size] );
            copy_buffer<BUFFER_CAP>( buffer_1.data(), &container_1.data()[current_size] );
            
            current_size += BUFFER_CAP;
            current_buffer_size = 0;
        }
        
        void Expand() const
        {
            RequireCapacity( LInt(2) * capacity );
        }
    };
    
} // namespace Tensors
