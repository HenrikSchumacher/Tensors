#pragma once

namespace Tensors
{
    template<typename T_0, typename Int>
    class alignas(ObjectAlignment) Aggregator final
    {
        // A dynamically growing version of Tensor1 that allows pushing of several elements at once.
        // It also allows decently fast access with the operator[].
        
        // Setting thread_count higher than 1 can speed up copy operations -- but only if sufficiently many threads are free and only if there is sufficient RAM bandwidth.
        // Better set thread_count = 1 if you want to use more than one Aggregator at a time.
        
        
        // TODO: It might be a better idea to use a std::vector of Tensor1s and then grow it.
        // TODO: There will be some overhead for indexing into this nested data structure, though.
        // TODO: And using &operator[i] is asking for trouble...
        
        static_assert(IntQ<Int>,"");

        using Container_0_T = Tensor1<T_0,Int>;

        Int current_size   = 0;
        Int capacity       = 1;
        
        Container_0_T container_0 {capacity};

        Int thread_count = 1;
        
    public:

        explicit Aggregator( const Int n )
        :   current_size ( Int(0)        )
        ,   capacity     ( Max(Int(1),n) )
        ,   container_0  ( Max(Int(1),n) )
        ,   thread_count ( Int(1)        )
        {}
        
        explicit Aggregator( const Int n, const Int thread_count_ )
        :   current_size ( Int(0)        )
        ,   capacity     ( Max(Int(1),n) )
        ,   container_0  ( Max(Int(1),n) )
        ,   thread_count ( thread_count_ )
        {}

        // Default constructor
        Aggregator() = default;
        
        // Since we declare no user-defined destructor, suitable copy constructor, copy assignment, move constructor, and copy assignment will be generated by compiler.
        
//        // Destructor
//        ~Aggregator() = default;
//        // Copy constructor
//        Aggregator( const Aggregator & other ) = default;
//
//        friend void swap ( Aggregator & A, Aggregator & B ) noexcept
//        {
//            using std::swap;
//            
//            swap( A.current_size, B.current_size );
//            swap( A.capacity,     B.capacity     );
//            swap( A.container_0,  B.container_0  );
//            swap( A.thread_count, B.thread_count );
//        }
//        
//        // Copy assignment operator
//        Aggregator & operator=( Aggregator other ) noexcept
//        {   //                                 ^
//            //                                 |
//            // Use the copy constructor -------+
//            swap( *this, other );
//            return *this;
//        }
//
//        // Move constructor
//        Aggregator( Aggregator && other ) noexcept
//        :   Aggregator()
//        {
//            swap(*this, other);
//        }


        Int Size() const
        {
            return current_size;
        }

        TOOLS_FORCE_INLINE void Push( const T_0 a )
        {
            if( current_size >= capacity )
            {
                Expand();
            }

            container_0[current_size++] = a;
        }
        
        TOOLS_FORCE_INLINE void Push( cptr<T_0> a, const Int n )
        {
            if( current_size + n >= capacity )
            {
                RequireCapacity( Max( current_size + n, Int(2) * capacity ) );
            }

            copy_buffer( a, &container_0[current_size], static_cast<Size_T>(Ramp(n)) );
            current_size += n;
        }
        
        TOOLS_FORCE_INLINE void Pop( const Int n )
        {
            if( current_size >= n )
            {
                current_size -= n;
            }
            else
            {
                wprint( ClassName()+"::Pop: Attempt to pop " + ToString(n) + " elements although only " + ToString(current_size) +" elements are present. Emptying container.");
                
                current_size = 0;
            }
        }

        Container_0_T & Get()
        {
            ShrinkToFit();
            
            return container_0;
        }

        const Container_0_T & Get() const
        {
            ShrinkToFit();
            
            return container_0;
        }
        
        // A bit dangerous, this is. But since we do not use any buffering, this might work.
        cptr<T_0> data() const
        {
            return container_0.data();
        }
        
        template<typename S>
        void Write( S * target ) const
        {
            copy_buffer( container_0.data(), target, current_size );
        }
        

    public:

        Int Capacity() const
        {
            return capacity;
        }
        
        void RequireCapacity( const Int new_capacity )
        {
            TOOLS_PTIC(ClassName()+"::RequireCapacity");
            if( new_capacity > capacity)
            {
                Container_0_T new_container_0 (new_capacity);
                
                copy_buffer<VarSize,Parallel>(
                    container_0.data(), new_container_0.data(), capacity, thread_count
                );
                
                using std::swap;
                swap( container_0, new_container_0 );
                
                capacity = new_capacity;
            }
            TOOLS_PTOC(ClassName()+"::RequireCapacity");
        }
        
        TOOLS_FORCE_INLINE T_0 & operator[]( const Int i )
        {
            return container_0[i];
        }
        
        TOOLS_FORCE_INLINE const T_0 & operator[]( const Int i ) const
        {
            return container_0[i];
        }
        
        void ShrinkToFit()
        {
            TOOLS_PTIC(ClassName()+"::ShrinkToFit");
            
            if( current_size != capacity )
            {
                Container_0_T new_container_0 ( current_size );
                
                new_container_0.ReadParallel( container_0.data(), thread_count );
                
                using std::swap;
                swap( container_0, new_container_0 );
            }
            
            TOOLS_PTOC(ClassName()+"::ShrinkToFit");
        }
        
    protected:
        
        void Expand()
        {
            RequireCapacity( Scalar::Two<Int> * capacity );
        }
        
    public:
        
        inline friend std::string ToString(
            cref<Aggregator> A, std::string line_prefix = std::string("")
        )
        {
            return ArrayToString( A.data(), {A.Size()}, line_prefix );
        }
        
    public:
        
        std::string ClassName() const
        {
            return std::string("Aggregator")+"<"+TypeName<T_0>+","+TypeName<Int>+">";
        }
    };
    
    
#ifdef LTEMPLATE_H
        
    template<
        typename T, typename Int,
        class = typename std::enable_if_t<mma::HasTypeQ<T>>
    >
    inline mma::TensorRef<mma::Type<T>> to_MTensorRef( cref<Aggregator<T,Int>> agg )
    {
        mint d = agg.Size();
        auto A = mma::makeTensor<mma::Type<T>>( mint(1), &d );
        agg.Write( A.data() );
        
        return A;
    }
    
#endif
    
} // namespace Tensors
