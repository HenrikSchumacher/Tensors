#pragma once

namespace Tensors
{
    // TODO: It could be helpful to track min and max of the three containers (at least of the first two) as these might be needed for a later assembly.
    template<typename T_0, typename T_1, typename T_2, typename Int>
    class alignas(ObjectAlignment) TripleAggregator final
    {
        static_assert(IntQ<Int>,"");
        
        // Int -- an integer type capable of storing the number of triples to aggregate.
        
        using Container_0_T = Tensor1<T_0,Int>;
        using Container_1_T = Tensor1<T_1,Int>;
        using Container_2_T = Tensor1<T_2,Int>;

        mutable Int current_size = 0;
        mutable Int capacity     = 1;
        
        mutable Container_0_T container_0 {capacity};
        mutable Container_1_T container_1 {capacity};
        mutable Container_2_T container_2 {capacity};

    public:
        
        explicit TripleAggregator( const Int n )
        :   current_size ( Int(0)   )
        ,   capacity     ( Int(n)   )
        ,   container_0  ( capacity )
        ,   container_1  ( capacity )
        ,   container_2  ( capacity )
        {}

        // Default constructor
        TripleAggregator() = default;
        
        // Since we declare no user-defined destructor, suitable copy constructor, copy assignment, move constructor, and copy assignment will be generated by compiler.

        Int Size() const
        {
            return current_size;
        }
        
        void Clear()
        {
            current_size = Int(0);
        }
        
        TOOLS_FORCE_INLINE
        void Push( cref<T_0> a_0, cref<T_1> a_1, cref<T_2> a_2 )
        {
            if( current_size >= capacity )
            {
                Expand();
            }

            container_0[current_size] = a_0;
            container_1[current_size] = a_1;
            container_2[current_size] = a_2;
            ++current_size;
        }
        
        TOOLS_FORCE_INLINE
        void Push( T_0 && a_0, T_1 && a_1, T_2 && a_2 )
        {
            if( current_size >= capacity ) { Expand(); }

            container_0[current_size] = std::move(a_0);
            container_1[current_size] = std::move(a_1);
            container_2[current_size] = std::move(a_2);
            ++current_size;
        }

//        mref<Container_0_T> Get_0()
//        {
//            ShrinkToFit();
//            return container_0;
//        }
//
//        cref<Container_0_T> Get_0()
//        {
//            ShrinkToFit();
//            return container_0;
//        }
//
//        mref<Container_1_T> Get_1()
//        {
//            ShrinkToFit();
//            return container_1;
//        }
//
//        cref<Container_1_T> Get_1()
//        {
//            ShrinkToFit();
//            return container_1;
//        }
//        
//        mref<Container_2_T> Get_2()
//        {
//            ShrinkToFit();
//            return container_2;
//        }
//
//        cref<Container_2_T> Get_2()
//        {
//            ShrinkToFit();
//            return container_2;
//        }
        
        Container_0_T Disband_0()
        {
            ShrinkToFit();
            return std::move(container_0);
        }
        
        Container_1_T Disband_1()
        {
            ShrinkToFit();
            return std::move(container_1);
        }
        
        Container_2_T Disband_2()
        {
            ShrinkToFit();
            return std::move(container_2);
        }
        
        
        // A bit dangerous, this is. But since we do not use any buffering, this might work.
        cptr<T_0> data_0() const
        {
            return container_0.data();
        }
        
        cptr<T_1> data_1() const
        {
            return container_1.data();
        }
        
        cptr<T_2> data_2() const
        {
            return container_2.data();
        }

    public:

        Int Capacity() const
        {
            return capacity;
        }
        
        void RequireCapacity( const Int new_capacity )
        {            
            if( new_capacity > capacity)
            {
                SetCapacity( new_capacity );
            }
        }
        
        void SetCapacity( const Int new_capacity )
        {
            TOOLS_PTIMER(timer,MethodName("SetCapacity"));

#ifdef TENSORS_ALLOCATION_LOGS
            TOOLS_LOGDUMP(capacity);
            TOOLS_LOGDUMP(new_capacity);
#endif
            
            Container_0_T new_container_0 (new_capacity);
            Container_1_T new_container_1 (new_capacity);
            Container_2_T new_container_2 (new_capacity);
            
            const Int s = Min( capacity, new_capacity );
            
            std::move(
                container_0.data(),
                container_0.data(s),
                new_container_0.data()
            );
            std::move(
                container_1.data(),
                container_1.data(s),
                new_container_1.data()
            );
            std::move(
                container_2.data(),
                container_2.data(s),
                new_container_2.data()
            );
            
            using std::swap;
            swap( container_0, new_container_0 );
            swap( container_1, new_container_1 );
            swap( container_2, new_container_2 );
            
            capacity = new_capacity;
        }
        
        void ShrinkToFit()
        {
            if( capacity > current_size )
            {
                SetCapacity(current_size);
            }
        }
        
    protected:
        
        void Expand()
        {
            SetCapacity( Int(2) * capacity );
        }
        
        
        static std::string MethodName( const std::string & tag )
        {
            return ClassName() + "::" + tag;
        }
        
        static std::string ClassName()
        {
            return std::string("TripleAggregator")+"<"+TypeName<T_0>+","+TypeName<T_1>+","+TypeName<T_2>+","+TypeName<Int>+">";
        }
    };

    
} // namespace Tensors
