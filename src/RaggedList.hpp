#pragma once

namespace Tensors
{
    template<typename T_, typename Int_>
    class RaggedList final
    {
        static_assert(IntQ<Int_>,"");
    public:
        
        using T   = T_;
        using Int = Int_;

        RaggedList(
            const Int expected_sublist_count,
            const Int expected_element_t_count
        )
        : ptrs(expected_sublist_count + Int(1))
        , elements(expected_element_t_count)
        {
            ptrs.Push(Int(0));
        }
        
        // Default constructor
        RaggedList()
        : ptrs(Int(1))
        {
            ptrs.Push(Int(0));
        }
        
        // Since we declare no user-defined destructor, suitable copy constructor, copy assignment, move constructor, and copy assignment will be generated by compiler.
        
        class Sublist_T
        {
            
        private:
            
            const T * sublist_begin = nullptr;
            const T * sublist_end   = nullptr;
            
        public:
            
            Sublist_T( const T * begin_, const T * end_ )
            :   sublist_begin ( begin_ )
            ,   sublist_end   ( end_ )
            {}
//            mptr<T> begin()
//            {
//                return sublist_begin;
//            }
            
            cptr<T> begin() const
            {
                return sublist_begin;
            }
            
//            mptr<T> end()
//            {
//                return sublist_end;
//            }
            
            cptr<T> end() const
            {
                return sublist_end;
            }
            
            Int Size() const
            {
                return std::distance( sublist_begin, sublist_end );
            }
            
            template<typename S>
            void Write( mptr<S> target ) const
            {
                if( sublist_begin == nullptr || sublist_end == nullptr )
                {
                    eprint(ClassName() + "::Write: Sublist is invalid. Doing nothing.");
                    return;
                }
                
                if constexpr ( SameQ<T,S> )
                {
                    std::copy( sublist_begin, sublist_end, target );
                }
                else
                {
                    std::transform( sublist_begin, sublist_end, target, static_caster<T,S>() );
                }
            }
            
            template<typename S>
            void Read( mptr<S> target )
            {
                if( sublist_begin == nullptr || sublist_end == nullptr )
                {
                    eprint(ClassName() + "::Write: Sublist is invalid. Doing nothing.");
                    return;
                }
                
                if constexpr ( SameQ<T,S> )
                {
                    std::copy( target, &target[Size()], sublist_begin );
                }
                else
                {
                    std::transform( target, &target[Size()], sublist_begin, static_caster<S,T>() );
                }
            }
            
            friend std::string ToString( cref<Sublist_T> s )
            {
                return ArrayToString( s.begin(), {s.Size()} );
            }
            
            std::string ClassName() const
            {
                return std::string("RaggedList")
                    + "<" + TypeName<T>
                    + "," + TypeName<Int>
                    + ">::Sublist_T";
            }
        };
        
    private:
        
        Aggregator<Int,Int> ptrs;
        Aggregator<T  ,Int> elements;
        
    public:
        
//        mref<Aggregator<Int,Int>> Pointers()
//        {
//            return ptrs;
//        }
        
        cref<Aggregator<Int,Int>> Pointers() const
        {
            return ptrs;
        }
        
//        mref<Aggregator<T,Int>> Elements()
//        {
//            return elements;
//        }
        
        cref<Aggregator<T,Int>> Elements() const
        {
            return elements;
        }
        
        void FinishSublist()
        {
            ptrs.Push(elements.Size());
        }
        
        void Push( cref<T> x )
        {
            elements.Push(x);
        }
        
        void Push( T && x )
        {
            elements.Push(std::move(x));
        }
        
        template<typename S>
        void Push( cptr<S> x, const Int n )
        {
            elements.Push(x,n);
        }
        
        Int SublistCount() const
        {
            return ptrs.Size() - Int(1);
        }
        
        Int ElementCount() const
        {
            return elements.Size();
        }
        
        Int SublistSize( const Int i ) const
        {
            if( (Int(0) <= i) && (i < SublistCount() ) )
            {
                return ptrs[i+1] - ptrs[i];
            }
            else if ( i == SublistCount() )
            {
                return elements.Size() - ptrs[i];
            }
            else
            {
                return Int(0);
            }
        }
        
        Sublist_T Sublist( const Int i ) const
        {
            if( (Int(0) <= i) && (i < SublistCount() ) )
            {
                return Sublist_T( { &elements[ptrs[i]], &elements[ptrs[i+1]] } );
            }
            else if ( i == SublistCount() )
            {
                return Sublist_T( { &elements[ptrs[i]], &elements[elements.Size()] } );
            }
            else
            {
                return Sublist_T( { &elements[0], &elements[0] } );
            }
        }
        
        std::pair<Tensor1<Int,Int>,Tensor1<T,Int>> Disband()
        {
            return std::pair{ ptrs.Disband(), elements.Disband() };
        }
        
    public:
        
        friend std::string ToString(
            cref<RaggedList> list,
            std::string line_prefix = ""
        )
        {
            std::string prefix = line_prefix + "\t";
            
            std::string str = line_prefix + "{\n";
            {
                const Int s = 0;
                str += prefix;
                str += ToString(list.Sublist(s));
            }
            
            const Int s_count = list.SublistCount();
            
            for( Int s = 1; s < s_count; ++s )
            {
                str += ",\n";
                str += prefix;
                str += ToString(list.Sublist(s) );
            }
            
            str += "\n";
            str += line_prefix;
            str += "}\n";
            
            return str;
        }
        
        std::string ClassName() const
        {
            return std::string("RaggedList")
                + "<" + TypeName<T>
                + "," + TypeName<Int>
                + ">";
        }
        
    }; // class RaggedList
    
    
#ifdef LTEMPLATE_H
        
    template<
        typename T, typename Int,
        class = typename std::enable_if_t<mma::HasTypeQ<T>>
    >
    inline mma::TensorRef<mma::Type<T>> to_MTensorRef(
        const typename RaggedList<T,Int>::Sublist & sublist
    )
    {
        mint d = sublist.Size();
        auto A = mma::makeTensor<mma::Type<T>>( mint(1), &d );
        sublist.Write( A.data() );
        
        return A;
    }
    
    template<
        typename S, typename Int,
        class = typename std::enable_if_t<mma::HasTypeQ<S>>
    >
    inline mma::TensorRef<mma::Type<S>> to_MTensorRef(
        const RaggedList<S,Int> & a
    )
    {
        using T = mma::Type<S>;
        
        mint L = a.SublistCount();
        mint d = mint(2) + L + a.ElementCount();
        auto A = mma::makeTensor<T>( mint(1), &d );
        A.data()[0] = static_cast<T>(L);
        
        a.Pointers().Write( &A.data()[mint(1)] );
        a.Elements().Write( &A.data()[L+mint(2)] );
        
        return A;
    }
    
#endif
    
} // namespace Tensors
