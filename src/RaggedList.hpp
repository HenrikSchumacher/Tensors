#pragma once

namespace Tensors
{
    template<typename T_, typename Int_>
    class RaggedList final
    {
        static_assert(IntQ<Int_>,"");
    public:
        
        using T   = T_;
        using Int = Int_;

        RaggedList(
            const Int expected_sublist_count,
            const Int expected_element_t_count
        )
        : ptrs(expected_sublist_count + Int(1))
        , elements(expected_element_t_count)
        {
            ptrs.Push(Int(0));
        }
        
        // Default constructor
        RaggedList()
        : ptrs(Int(1))
        {
            ptrs.Push(Int(0));
        }
        
        // Since we declare no user-defined destructor, suitable copy constructor, copy assignment, move constructor, and copy assignment will be generated by compiler.
        
//        // Destructor
//        ~RaggedList() = default;
//        
//        // Copy constructor
//        RaggedList( const RaggedList & other ) = default;
//        
//        friend void swap ( RaggedList & A, RaggedList & B ) noexcept
//        {
//            using std::swap;
//            
//            swap( A.ptrs        , B.ptrs        );
//            swap( A.elements    , B.elements    );
//        }
//        
//        // Copy assignment operator
//        RaggedList & operator=( RaggedList other ) noexcept
//        {   //                               ^
//            //                               |
//            // Use the copy constructor -----+
//            swap( *this, other );
//            return *this;
//        }
//
//        // Move constructor
//        RaggedList( RaggedList && other ) noexcept
//        :   RaggedList()
//        {
//            swap(*this, other);
//        }
        
        class Sublist_T
        {
            
        private:
            
            const T * sublist_begin = nullptr;
            const T * sublist_end   = nullptr;
            
        public:
            
            Sublist_T( const T * begin_, const T * end_ )
            :   sublist_begin ( begin_ )
            ,   sublist_end   ( end_ )
            {}
//            mptr<T> begin()
//            {
//                return sublist_begin;
//            }
            
            cptr<T> begin() const
            {
                return sublist_begin;
            }
            
//            mptr<T> end()
//            {
//                return sublist_end;
//            }
            
            cptr<T> end() const
            {
                return sublist_end;
            }
            
            Int Size() const
            {
                return std::distance( sublist_begin, sublist_end );
            }
            
            template<typename S>
            void Write( mptr<S> target ) const
            {
                if( sublist_begin == nullptr || sublist_end == nullptr )
                {
                    eprint(ClassName() + "::Write: Sublist is invalid. Doing nothing.");
                    return;
                }
                
                if constexpr ( SameQ<T,S> )
                {
                    std::copy( sublist_begin, sublist_end, target );
                }
                else
                {
                    std::transform( sublist_begin, sublist_end, target, static_caster<T,S>() );
                }
            }
            
            template<typename S>
            void Read( mptr<S> target )
            {
                if( sublist_begin == nullptr || sublist_end == nullptr )
                {
                    eprint(ClassName() + "::Write: Sublist is invalid. Doing nothing.");
                    return;
                }
                
                if constexpr ( SameQ<T,S> )
                {
                    std::copy( target, &target[Size()], sublist_begin );
                }
                else
                {
                    std::transform( target, &target[Size()], sublist_begin, static_caster<S,T>() );
                }
            }
            
            friend std::string ToString( cref<Sublist_T> s )
            {
                return ArrayToString( s.begin(), {s.Size()} );
            }
            
            std::string ClassName() const
            {
                return std::string("RaggedList")
                    + "<" + TypeName<T>
                    + "," + TypeName<Int>
                    + ">::Sublist_T";
            }
        };
        
    private:
        
        Aggregator<Int,Int> ptrs;
        Aggregator<T,Int>   elements;
        
    public:
        
//        mref<Aggregator<Int,Int>> Pointers()
//        {
//            return ptrs;
//        }
        
        cref<Aggregator<Int,Int>> Pointers() const
        {
            return ptrs;
        }
        
//        mref<Aggregator<T,Int>> Elements()
//        {
//            return elements;
//        }
        
        cref<Aggregator<T,Int>> Elements() const
        {
            return elements;
        }
        
        void FinishSublist()
        {
            ptrs.Push(elements.Size());
        }
        
        void Push( const T x )
        {
            elements.Push(x);
        }
        
        Int SublistCount() const
        {
            return ptrs.Size() - Int(1);
        }
        
        Int ElementCount() const
        {
            return elements.Size();
        }
        
        Int SublistSize( const Int i ) const
        {
            if( (Int(0) <= i) && (i < SublistCount() ) )
            {
                return ptrs[i+1] - ptrs[i];
            }
            else if ( i == SublistCount() )
            {
                return elements.Size() - ptrs[i];
            }
            else
            {
                return Int(0);
            }
        }
        
        Sublist_T Sublist( const Int i ) const
        {
            if( (Int(0) <= i) && (i < SublistCount() ) )
            {
                return Sublist_T( { &elements[ptrs[i]], &elements[ptrs[i+1]] } );
            }
            else if ( i == SublistCount() )
            {
                return Sublist_T( { &elements[ptrs[i]], &elements[elements.Size()] } );
            }
            else
            {
                return Sublist_T( { &elements[0], &elements[0] } );
            }
        }
        
    public:
        
        friend std::string ToString(
            cref<RaggedList> list,
            std::string line_prefix = ""
        )
        {
            std::string prefix = line_prefix + "\t";
            
            std::string str = line_prefix + "{\n";
            {
                const Int s = 0;
                str += prefix;
                str += ToString(list.Sublist(s));
            }
            for( Int s = 1; s < list.SublistCount(); ++s )
            {
                str += ",\n";
                str += prefix;
                str += ToString(list.Sublist(s) );
            }
            
            str += "\n";
            str += line_prefix;
            str += "}\n";
            
            return str;
        }
        
        std::string ClassName() const
        {
            return std::string("RaggedList")
                + "<" + TypeName<T>
                + "," + TypeName<Int>
                + ">";
        }
        
    }; // class RaggedList
    
    
#ifdef LTEMPLATE_H
        
    template<
        typename T, typename Int,
        class = typename std::enable_if_t<mma::HasTypeQ<T>>
    >
    inline mma::TensorRef<mma::Type<T>> to_MTensorRef(
        typename RaggedList<T,Int>::Sublist & sublist
    )
    {
        mint d = sublist.Size();
        auto A = mma::makeTensor<mma::Type<T>>( mint(1), &d );
        sublist.Write( A.data() );
        
        return A;
    }
    
#endif
    
} // namespace Tensors
